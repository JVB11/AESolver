"""Pytest file used to test the values generated by the classes in the combinations module.

Author: Jordan Van Beeck <jordanvanbeeck@hotmail.com>
"""
# import modules
import pytest
import json
import numpy as np
import itertools

# import pytest util class
from value_subclass import EVsList

# import custom modules to be tested
from py_combinations.cartesian_combinations import CartesianCombos
from py_combinations.single_set_combinations import SingleSetCombos
from py_combinations.symmetric_product import SymmetricProductCombos


# # # # # TEST SingleSetCombos object computation method # # # # #


# define the test inputs for 'SingleSetCombos'
class SingleInputs(EVsList):
    """Defines the test inputs for 'SingleSetCombos'."""

    INPUT_1 = json.dumps([15, 20, 25])
    INPUT_2 = np.array([15.0, 20.0, 25.0]).tobytes()
    INPUT_3 = json.dumps(list(range(10, 16)))
    INPUT_4 = json.dumps([15])
    INPUT_5 = json.dumps([])


# define the test results for 'SingleSetCombos'
class SingleOutputs(EVsList):
    """Defines the test output for 'SingleSetCombos'."""

    RESULT_1 = json.dumps([(15, 20), (15, 25), (20, 25)])
    RESULT_2 = json.dumps([(15.0, 20.0), (15.0, 25.0), (20.0, 25.0)])
    RESULT_3 = json.dumps(list(itertools.combinations(range(10, 16), 2)))
    RESULT_4 = json.dumps([])
    RESULT_5 = json.dumps([])


# test class to check values of 'SingleSetCombos'
@pytest.mark.parametrize(
    ('my_input', 'expected_result'),
    [(i, r) for i, r in zip(SingleInputs.get_list(), SingleOutputs.get_list())],
)
class TestSingleSetCombos:
    """Class containing test method used to test result of the 'SingleSetCombos' object computation method."""

    def test_result_single_set_combos(self, my_input, expected_result):
        """Tests the result of the SingleSetCombos computation.

        Parameters
        ----------
        my_input : list | np.ndarray
            Contains the elements for which the pair-wise combinations need to be generated.
        expected_result : list
            Contains the possible pair-wise combinations.
        """
        # initialize the object
        my_obj = SingleSetCombos(my_set=my_input)
        # compute the cardinality of the expected result
        expected_cardinality = len(expected_result)
        # assert that the outcome is as required
        assert (my_obj.c, my_obj.l) == (expected_cardinality, expected_result)


# # # # # TEST CartesianCombos object computation method # # # # #


# define the test inputs for 'CartesianCombos'
class CartesianInputs(EVsList):
    """Defines the test inputs for 'CartesianCombos'."""

    INPUT_1 = json.dumps([(1, 2), (3, 4)])
    INPUT_2 = json.dumps([(1, 2), (2, 3)])
    INPUT_3 = json.dumps([(1, 2), (1, 2)])
    INPUT_4 = np.array([(1, 2), (1, 2)], dtype=int).tobytes()


# define the test results for 'CartesianCombos'
class CartesianOutputs(EVsList):
    """Defines the test outputs for 'CartesianCombos'."""

    RESULT_1 = json.dumps([(1, 3), (1, 4), (2, 3), (2, 4)])
    RESULT_2 = json.dumps([(1, 2), (1, 3), (2, 2), (2, 3)])
    RESULT_3 = json.dumps([(1, 1), (1, 2), (2, 1), (2, 2)])
    RESULT_4 = json.dumps([(1, 1), (1, 2), (2, 1), (2, 2)])


# test class to check values of 'CartesianCombos'
@pytest.mark.parametrize(
    ('my_input', 'expected_result'),
    [
        (i, r)
        for i, r in zip(
            CartesianInputs.get_list(
                dtype_buffered=int, shape_list=[None, None, None, (2, 2)]
            ),
            CartesianOutputs.get_list(),
        )
    ],
)
class TestCartesianCombs:
    """Class containing test method used to test result of the 'CartesianCombos' object computation method."""

    def test_result_cartesian_combs(self, my_input, expected_result):
        """Tests the result of the CartesianCombos computation.

        Parameters
        ----------
        my_input : list or np.ndarray
            Contains the elements for which the pair-wise combinations need to be generated.
        expected_result : list
            Contains the possible pair-wise combinations.
        """
        # initialize the object
        my_obj = CartesianCombos(set_A=my_input[0], set_B=my_input[1])
        # compute the cardinality of the expected result
        expected_cardinality = len(expected_result)
        # assert that the outcome is as required
        assert (my_obj.c, my_obj.l) == (expected_cardinality, expected_result)


# # # # # TEST SymmetricProductCombos object computation method # # # # #


# the test inputs for 'SymmetricProductCombos' are the same as those for the 'CartesianCombos' --> No need for redefinition!


# define the test results for 'SymmetricProductCombos'
class SymmetricOutputs(EVsList):
    """Defines the test outputs for 'SymmetricProductCombos'."""

    RESULT_1 = json.dumps(
        [[(2, 3), (2, 4), (1, 3), (1, 4)], [(2, 3), (2, 4), (1, 3), (1, 4)]]
    )
    RESULT_2 = json.dumps(
        [[(2, 3), (1, 2), (1, 3), (2, 2)], [(2, 3), (1, 2), (1, 3)]]
    )
    RESULT_3 = json.dumps([[(1, 2), (1, 1), (2, 2)], [(1, 2)]])
    RESULT_4 = json.dumps([[(1, 2), (1, 1), (2, 2)], [(1, 2)]])


# test class to check values of 'SymmetricProductCombos'
@pytest.mark.parametrize(
    (
        'my_input',
        'expected_result_with_diagonal',
        'expected_result_no_diagonal',
    ),
    [
        (i, r[0], r[1])
        for i, r in zip(
            CartesianInputs.get_list(
                dtype_buffered=int, shape_list=[None, None, None, (2, 2)]
            ),
            SymmetricOutputs.get_list(tuple_conversion=False),
        )
    ],
)
class TestSymmetricProductCombos:
    """Class containing test method used to test results of the 'SymmetricProductCombos' object computation method."""

    def test_result_sym_prod(
        self,
        my_input,
        expected_result_with_diagonal,
        expected_result_no_diagonal,
    ):
        """Tests the result of the SymmetricProductCombos computation.

        Parameters
        ----------
        my_input : list | np.ndarray
            Contains the elements for which the pair-wise combinations need to be generated.
        expected_result_with_diagonal : list
            Contains the possible pair-wise combinations, allowing for overlap.
        expected_result_no_diagonal : list
            Contains the possible pair-wise combinations, not allowing for overlap.
        """
        # initialize the test objects
        my_obj_overlap = SymmetricProductCombos(
            A=my_input[0], B=my_input[1], include_diagonal=True
        )
        my_obj_no_overlap = SymmetricProductCombos(
            A=my_input[0], B=my_input[1], include_diagonal=False
        )
        # compute the cardinality of the expected result
        expected_cardinality_with_diagonal = len(expected_result_with_diagonal)
        expected_cardinality_no_diagonal = len(expected_result_no_diagonal)
        # convert to tuples members in expected output for sake of test
        # --> NEEDS TO BE DONE DUE TO TEST SETUP..
        expected_result_no_diagonal = [
            tuple(x) for x in expected_result_no_diagonal
        ]
        expected_result_with_diagonal = [
            tuple(x) for x in expected_result_with_diagonal
        ]
        # assert that the outcome is as required
        assert (
            my_obj_overlap.c,
            my_obj_overlap.l,
            my_obj_no_overlap.c,
            my_obj_no_overlap.l,
        ) == (
            expected_cardinality_with_diagonal,
            expected_result_with_diagonal,
            expected_cardinality_no_diagonal,
            expected_result_no_diagonal,
        )
